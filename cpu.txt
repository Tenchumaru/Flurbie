Op Codes
========

Register Op Codes
-----------------

There are fourteen of them:
add, addc, sub, subb, mul, umul, div, udiv, and, nand, or, nor, xor, xnor

Addressing modes:
register-register:  op tr, lr, rr (with optional shift)
register-immediate:  op tr, lr, value

Memory Op Codes
---------------

There are four of them:
ld, ldi, ori, st

Special Op Codes
----------------

There is only one so far:
cx

Patterns
--------

31      1       instruction active if CNVZ mask with CNVZ flags is non-zero
        0       instruction active if CNVZ mask with CNVZ flags is zero
30      C mask
29      N mask
28      V mask
27      Z mask
26-23   op code (add, addc, sub, subb, mul, umul, div, udiv, and, nand, or, nor, xor, xnor, MEM, SPECIAL)

standard:
22-18   target register (tr, 0-31)
17      source2 mode
        0       immediate source2
        1       register source2
16-12   left register (lr, 0-31)

immediate source2:  tr= lr op value
11-0    12-bit value sign-extended to 32 bits

register source2:  tr= lr op (rr shop value)
11-7    right register (rr, 0-31)
6-5     shift operation
        00      add -16 to 15
        01      left
        10      logical right
        11      arithmetic right
4-0     5-bit value (0-31)

MEM:
22-18   register (r, 0-31)
17-16   mop
        00      ld
        01      ldi
        10      ori
        11      store

ld:  r= *(ar + value)
15-11   address register (ar, 0-31)
10-0    11-bit value sign-extended to 32 bits

ldi:  r= value
15-0    16-bit value sign-extended to 32 bits

ori:  r |= value
15-0    16-bit unsigned value

store:  *(ar + value)= r
15-11   address register (ar, 0-31)
10-0    11-bit value sign-extended to 32 bits

SPECIAL:  tr= *ar; if(tr == cr) *ar= sr;
22-18   target register (tr, 0-31)
17      unused
16-12   compare register (cr, 0-31)
11-7    source register (sr, 0-31)
6-2     address register (ar, 0-31)
1-0     unused

r31 is flags (User mode is in bit 31, CNVZ are in bits 30-27)
r30 is IP (instruction pointer)
r29 is SP (stack pointer; by convention)
r28 is FP (frame pointer; by convention)
r0 is always zero
Supervisor mode has its own copies of r16 through r31.
Consider having supervisor mode see user mode's r17 through r31 in its r1
through r15 with its own copies of r16 through r31.  r0 is still always zero.

Operation Forms
---------------
immediate source2:  tr= lr op (R0 + value12)
register source2:   tr= lr op (rr shop value5)
ld:                 tr= R0 | *(ar + value11)
ldi:                tr= R0 | (R0 + value15)
ori:                tr= tr | (R0 + value15)
store:              *(ar + value11)= tr | (R0 << value11)
SPECIAL:            tr= *(ar + 0); if(tr == lr) *(ar + 0)= (rr + 0);
